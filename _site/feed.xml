<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Arbor</title>
    <description>Arbor workflows</description>
    <link>/arborCollections/arborCollections/</link>
    <atom:link href="/arborCollections/arborCollections/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Megatrees</title>
        <description>&lt;h2 id=&quot;megatrees&quot;&gt;Megatrees&lt;/h2&gt;

&lt;p&gt;TBA&lt;/p&gt;
</description>
        <pubDate>Wed, 07 Oct 2015 00:00:00 +0200</pubDate>
        <link>/arborCollections/arborCollections/tutorials/megatrees/</link>
        <guid isPermaLink="true">/arborCollections/arborCollections/tutorials/megatrees/</guid>
      </item>
    
      <item>
        <title>Web services</title>
        <description>&lt;h2 id=&quot;web-services&quot;&gt;Web services&lt;/h2&gt;

&lt;p&gt;TBA&lt;/p&gt;
</description>
        <pubDate>Wed, 02 Sep 2015 00:00:00 +0200</pubDate>
        <link>/arborCollections/arborCollections/tutorials/web-services/</link>
        <guid isPermaLink="true">/arborCollections/arborCollections/tutorials/web-services/</guid>
      </item>
    
      <item>
        <title>PGLS</title>
        <description>&lt;h2 id=&quot;use-pgls-to-test-for-a-correlation-between-two-continuous-variables&quot;&gt;Use PGLS to test for a correlation between two continuous variables&lt;/h2&gt;

&lt;p&gt;In this exercise, we will learn how to use PGLS to test for a correlation between two continuous variables. We will use the Arbor function “PGLS,” found in the phylogeny package.&lt;/p&gt;

&lt;p&gt;Imagine that you have a phylogenetic tree with information on two continuous character for some or all of the tips. You want to test whether or not there is an evolutionary correlation between the two traits. PGLS is the way to do this.&lt;/p&gt;

&lt;h2 id=&quot;loading-example-data&quot;&gt;Loading example data&lt;/h2&gt;

&lt;p&gt;For this example, we will use anolis again. Obtain the anolis example data files, phelsuma.phy and phelsuma.csv, from &lt;a href=&quot;/arborCollections/docs_datasets.html&quot;&gt;Arbor datasets&lt;/a&gt;. Save those files somewhere on your computer.&lt;/p&gt;

&lt;p&gt;Now open the &lt;a href=&quot;https://arbor.kitware.com&quot;&gt;Arbor web app&lt;/a&gt;. Drag and drop the two anolis data files on the blue “Browse or drop files” box to load them into your browser.&lt;/p&gt;

&lt;h2 id=&quot;selecting-the-collections-that-you-need&quot;&gt;Selecting the collections that you need&lt;/h2&gt;

&lt;p&gt;For this example, everything required is in the “phylogeny” collection - so click on that eyeball and you will be able to access the functions that you need.&lt;/p&gt;

&lt;p&gt;At this point, you should have the two anolis datafiles stored in Arbor and the “phylogeny” collection available.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/arborCollections/assets/PGLS/screen1.jpg&quot; alt=&quot;Screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;In this screenshot I am logged in but that is not necessary for this analysis.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;run-the-pgls-function&quot;&gt;Run the PGLS function&lt;/h2&gt;

&lt;p&gt;Find the PGLS function in the “phylogeny” collection. Select that function now. You can view the source code for it by choosing “show script” (it is in R).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/arborCollections/assets/PGLS/screen2.jpg&quot; alt=&quot;Screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We could use this function in a workflow, as we did in other Arbor tutorials. But for this tutorial let’s just run the function. To do that, click on the button that says “Setup and run.” In the resulting pop-up menu select the following options:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/arborCollections/assets/PGLS/screen3.jpg&quot; alt=&quot;Screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;We will be fitting the model SVL ~ awesomeness, so that SVL is the dependent and awesomeness the independent variable. “BM” means that we will fit a model that assumes that the residuals are distributed as expected under a Brownian motion model of evolution along the branches of the tree.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;run-your-analysis&quot;&gt;Run your analysis&lt;/h2&gt;

&lt;p&gt;Click “&amp;gt; Run” to run the function. Select these options. If your analysis worked, you should see the following message:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/arborCollections/assets/PGLS/screen4.jpg&quot; alt=&quot;Screenshot&quot; /&gt;.&lt;/p&gt;

&lt;h2 id=&quot;see-your-results&quot;&gt;See your results&lt;/h2&gt;

&lt;p&gt;Now move over to the “visualization” tab to see your results. The PGLS function creates three outputs: one table showing model coefficients like slopes and intercepts; one table showing a summary of model fit and parameter significance; and a plot.&lt;/p&gt;

&lt;p&gt;To see the table results, choose “table” and choose one of the outputs, either “PGLS coefficients” or “PGLS modelfit_summary”. Update shows you the table. For example, the coefficients look like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/arborCollections/assets/PGLS/screen5.jpg&quot; alt=&quot;Screenshot&quot; /&gt;.&lt;/p&gt;

&lt;p&gt;To see the plot, select “image” under “Select visualization”, and choose your  plot under “data” (it should be called PGLS pglsPlot). Click “update” to see this result:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/arborCollections/assets/PGLS/screen6.jpg&quot; alt=&quot;Screenshot&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;try-another-model&quot;&gt;Try another model&lt;/h2&gt;

&lt;p&gt;If you want to use a different option for PGLS, you can choose that in the setup and run window. For example, we can try OU like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/arborCollections/assets/PGLS/screen7.jpg&quot; alt=&quot;Screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You will notice that the coefficients are slightly different, though the main conclusion is unchanged.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/arborCollections/assets/PGLS/screen8.jpg&quot; alt=&quot;Screenshot&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 17 Jul 2015 00:00:00 +0200</pubDate>
        <link>/arborCollections/arborCollections/tutorials/PGLS-basic/</link>
        <guid isPermaLink="true">/arborCollections/arborCollections/tutorials/PGLS-basic/</guid>
      </item>
    
      <item>
        <title>Continuous ancestral character states</title>
        <description>&lt;h2 id=&quot;how-to-build-a-workflow-that-can-reconstruct-continuous-ancestral-character-states-on-nodes-in-your-tree-using-arbor&quot;&gt;How to build a workflow that can reconstruct continuous ancestral character states on nodes in your tree using Arbor&lt;/h2&gt;

&lt;p&gt;In this exercise, we will learn how to build a workflow that can reconstruct ancestral character states in Arbor for a continuous character - that is, a character that can take on any continuous value, like body weight or limb length.&lt;/p&gt;

&lt;p&gt;This exercise is quite similar to a tutorial for &lt;a href=&quot;/arborCollections/tutorials/reconstructing-ancestral-characters-discrete/&quot;&gt;ancestral state estimation of discrete characters&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Imagine that you have a phylogenetic tree with information on some continuous character for some or all of the tips. You want to use mathematical methods to reconstruct the ancestral character states on the internal nodes of the tree under a Brownian motion model. Then, this is the exercise for you!&lt;/p&gt;

&lt;h2 id=&quot;loading-example-data&quot;&gt;Loading example data&lt;/h2&gt;

&lt;p&gt;For this example, we will use a dataset where the species included in the tree and character data do not match perfectly. Obtain the day gecko example data files, phelsuma.phy and phelsuma.csv, from &lt;a href=&quot;/arborCollections/docs_datasets.html&quot;&gt;Arbor datasets&lt;/a&gt;. Save those files somewhere on your computer.&lt;/p&gt;

&lt;p&gt;If you look at these files, you will see that the tree includes a few unique species for which there is no character data. Arbor will recognize this and drop those species from the analysis.&lt;/p&gt;

&lt;p&gt;Now open the &lt;a href=&quot;https://arbor.kitware.com&quot;&gt;Arbor web app&lt;/a&gt;. Drag and drop the two phelsuma data files on the blue “Browse or drop files” box to load them into your browser.&lt;/p&gt;

&lt;p&gt;Finally, &lt;a href=&quot;/arborCollections/2015/06/09/creating-a-new-collection/&quot;&gt;log in and create a personal collection&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;selecting-the-collections-that-you-need&quot;&gt;Selecting the collections that you need&lt;/h2&gt;

&lt;p&gt;For this example, everything required is in the “phylogeny” collection - so click on that eyeball and you will be able to access the functions that you need.&lt;/p&gt;

&lt;p&gt;At this point, you should have the two anolis datafiles stored in Arbor and the “phylogeny” collection available. You should be logged in and have write access to your own private collection.&lt;/p&gt;

&lt;h2 id=&quot;set-up-your-workflow&quot;&gt;Set up your workflow&lt;/h2&gt;

&lt;p&gt;The main function in Arbor for ancestral state reconstruction is aceAcbor in the “phylogeny” collection. Select that function now. You can view the source code for it by choosing “show script” (it is in R).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/arborCollections/assets/continuousACE/screen1.png&quot; alt=&quot;Screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You will need to use this function in a workflow to calculate ancestral states and return the output. To start, create a new workflow called ContinuousAncestralStatesWorkflow”. Make sure to choose “New workflow” and not “New analysis”!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/arborCollections/assets/continuousACE/screen2.png&quot; alt=&quot;Screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now create the connections you need to make the workflow run. First, click the “edit” button to start working on the workflow.&lt;/p&gt;

&lt;p&gt;Now add the aceArbor function by selecting it under “Select analysis.” When you click “Add to workflow” then the function shoud appear in your workspace.&lt;/p&gt;

&lt;p&gt;Now create the inputs and outputs of the function by clicking on the “spokes” coming out of aceArbor. You should also move the blocks around to make your workflow look nice.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/arborCollections/assets/continuousACE/screen3.png&quot; alt=&quot;Screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;To see a more detailed walkthrough of making connections in your workflow, see the tutorial &lt;a href=&quot;/arborCollections/tutorials/reconstructing-ancestral-characters-discrete/&quot;&gt;ancestral state estimation of discrete characters&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Once you have a workflow that looks the way you want, click save!&lt;/strong&gt; If you do not do this you will be running the workflow at the last point it was saved and not what is shown on the screen.&lt;/p&gt;

&lt;h2 id=&quot;run-your-workflow&quot;&gt;Run your workflow&lt;/h2&gt;

&lt;p&gt;Click “Setup and run” to run your workflow. Select these options:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/arborCollections/assets/continuousACE/screen4.png&quot; alt=&quot;Screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If your analysis worked, you should see the following message:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/arborCollections/assets/continuousACE/screen6.png&quot; alt=&quot;Screenshot&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;see-your-results&quot;&gt;See your results&lt;/h2&gt;

&lt;p&gt;Now move over to the “visualization” tab to see your results. First, select “image” under “Select visualization”, and choose your tree plot under “data” (it should be called ContinuousAncestralStatesWorkflow treePlot). Click “update” to see this result:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/arborCollections/assets/continuousACE/screen7.png&quot; alt=&quot;Screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To see the results in table format, choose “table” and “ContinuousAncestralStatesWorkflow res”. Update gives you this table, which shows the ancestral state estimates and CIs for each node in the tree:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/arborCollections/assets/continuousACE/screen8.png&quot; alt=&quot;Screenshot&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 13 Jul 2015 00:00:00 +0200</pubDate>
        <link>/arborCollections/arborCollections/tutorials/reconstructing-ancestral-characters-continuous/</link>
        <guid isPermaLink="true">/arborCollections/arborCollections/tutorials/reconstructing-ancestral-characters-continuous/</guid>
      </item>
    
      <item>
        <title>Discrete ancestral character states</title>
        <description>&lt;h2 id=&quot;how-to-reconstruct-discrete-ancestral-character-states-on-nodes-in-your-tree-using-arbor&quot;&gt;How to reconstruct discrete ancestral character states on nodes in your tree using Arbor&lt;/h2&gt;

&lt;p&gt;In this exercise, we will learn how to reconstruct ancestral character states in Arbor for a discrete character - that is, a character that can take on one of a number of discrete values. Examples might be lizards, “legs” versus “no legs” - this would be a two-state discrete character. Another example would be animal locomotion - “walks,” “swims,” or “flies.” This is an example of a three-state discrete character.&lt;/p&gt;

&lt;p&gt;Imagine that you have a phylogenetic tree with information on some discrete character for some or all of the tips. You want to use mathematical methods to reconstruct the ancestral character states on the internal nodes of the tree. Then, this is the exercise for you!&lt;/p&gt;

&lt;h2 id=&quot;loading-example-data&quot;&gt;Loading example data&lt;/h2&gt;

&lt;p&gt;You will need the anolis example data files, anolis.phy and anolis.csv, from &lt;a href=&quot;/arborCollections/docs_datasets.html&quot;&gt;Arbor datasets&lt;/a&gt;. Save those files somewhere on your computer.&lt;/p&gt;

&lt;p&gt;Now open the &lt;a href=&quot;https://arbor.kitware.com&quot;&gt;Arbor web app&lt;/a&gt;. Drag and drop the two anolis data files on the blue “Browse or drop files” box to load them into your browser.&lt;/p&gt;

&lt;p&gt;Finally, &lt;a href=&quot;/arborCollections/2015/06/09/creating-a-new-collection/&quot;&gt;log in and create a personal collection&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;selecting-the-collections-that-you-need&quot;&gt;Selecting the collections that you need&lt;/h2&gt;

&lt;p&gt;For this example, everything required is in the “phylogeny” collection - so click on that eyeball and you will be able to access the functions that you need.&lt;/p&gt;

&lt;p&gt;At this point, you should have the two anolis datafiles stored in Arbor and the “phylogeny” collection available. You should be logged in and have write access to your own private collection.&lt;/p&gt;

&lt;h2 id=&quot;set-up-your-workflow&quot;&gt;Set up your workflow&lt;/h2&gt;

&lt;p&gt;The main function in Arbor for ancestral state reconstruction is aceAcbor in the “phylogeny” collection. Select that function now. You can view the source code for it by choosing “show script” (it is in R).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/arborCollections/assets/discreteACE/screen1.png&quot; alt=&quot;Screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You will need to use this function in a workflow to calculate ancestral states and return the output. To start, create a new workflow called “DiscreteAncestralStatesWorkflow”. Make sure to choose “New workflow” and not “New analysis”!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/arborCollections/assets/discreteACE/screen2.png&quot; alt=&quot;Screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now create the connections you need to make the workflow run. First, click the “edit” button to start working on the workflow.&lt;/p&gt;

&lt;p&gt;Now add the aceArbor function by selecting it under “Select analysis.” When you click “Add to workflow” then the function shoud appear in your workspace.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/arborCollections/assets/discreteACE/screen3.png&quot; alt=&quot;Screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now create the inputs and outputs of the function by clicking on the “spokes” coming out of aceArbor. You should also move the blocks around to make your workflow look nice.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/arborCollections/assets/discreteACE/functionPopup.gif&quot; alt=&quot;Screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Final result:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/arborCollections/assets/discreteACE/screen4.png&quot; alt=&quot;Screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Once you have a workflow that looks the way you want, click save!&lt;/strong&gt; If you do not do this you will be running the workflow at the last point it was saved and not what is shown on the screen.&lt;/p&gt;

&lt;h2 id=&quot;run-your-workflow&quot;&gt;Run your workflow&lt;/h2&gt;

&lt;p&gt;Click “Setup and run” to run your workflow. Select these options:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/arborCollections/assets/discreteACE/screen5.png&quot; alt=&quot;Screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If your analysis worked, you should see the following message:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/arborCollections/assets/discreteACE/screen6.png&quot; alt=&quot;Screenshot&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;see-your-results&quot;&gt;See your results&lt;/h2&gt;

&lt;p&gt;Now move over to the “visualization” tab to see your results. First, select “image” under “Select visualization”, and choose your tree plot under “data” (it should be called DiscreteAncestralStatesWorkflow treePlot). Click “update” to see this result:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/arborCollections/assets/discreteACE/screen7.png&quot; alt=&quot;Screenshot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To see the results in table format, choose “table” and “DiscreteAncestralStatesWorkflow res”. Update gives you this table, which is presently useless. Sorry!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/arborCollections/assets/discreteACE/screen8.png&quot; alt=&quot;Screenshot&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 10 Jun 2015 00:00:00 +0200</pubDate>
        <link>/arborCollections/arborCollections/tutorials/reconstructing-ancestral-characters-discrete/</link>
        <guid isPermaLink="true">/arborCollections/arborCollections/tutorials/reconstructing-ancestral-characters-discrete/</guid>
      </item>
    
      <item>
        <title>phylogeneticSignal</title>
        <description>&lt;h2 id=&quot;phylogeneticsignal-function&quot;&gt;phylogeneticSignal: function&lt;/h2&gt;

&lt;h3 id=&quot;collection-phylogenies&quot;&gt;collection: phylogenies&lt;/h3&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;aceArbor is a function for estimating and testing for phylogenetic signal. It works for
both discrete and continuous variables, and can use a variety of methods for calculating
phylogenetic signal.&lt;/p&gt;

&lt;h2 id=&quot;example&quot;&gt;Example&lt;/h2&gt;

&lt;p&gt;From the [docs] (/arborCollections/../docs/ ) page, get anolis.phy and anolis.csv.
Load these files into Arbor, and use them as inputs to the phylogeneticSignal function. Choose
the “SVL” column for analysis, and select type: lambda.&lt;/p&gt;

&lt;h2 id=&quot;arguments&quot;&gt;Arguments&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;table: A data table including species names&lt;/li&gt;
  &lt;li&gt;tree: A phylogenetic tree&lt;/li&gt;
  &lt;li&gt;column: The name of the column to analyze&lt;/li&gt;
  &lt;li&gt;method: either “K” for Blomberg’s K or “lambda” for Pagel’s lambda&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;outputs&quot;&gt;Outputs&lt;/h2&gt;
&lt;p&gt;Function outputs a table with results from the test of phylogenetic signal.&lt;/p&gt;
</description>
        <pubDate>Wed, 10 Jun 2015 00:00:00 +0200</pubDate>
        <link>/arborCollections/arborCollections/collections/phylogeny/phylogenetic-signal/</link>
        <guid isPermaLink="true">/arborCollections/arborCollections/collections/phylogeny/phylogenetic-signal/</guid>
      </item>
    
      <item>
        <title>aceArbor</title>
        <description>&lt;h1 id=&quot;acearbor-function&quot;&gt;aceArbor: function&lt;/h1&gt;

&lt;h3 id=&quot;collection-phylogenies&quot;&gt;collection: phylogenies&lt;/h3&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;aceArbor is a function for carrying out ancestral state reconstruction. It works for
both discrete and continuous variables, and can reconstruct ancestral character states
under both a maximum-likelihood and a Bayesian framework. The function returns results
in two formats: a table of ancestral state estimates for each node in the tree, and a plot
of the results.&lt;/p&gt;

&lt;h2 id=&quot;example&quot;&gt;Example&lt;/h2&gt;

&lt;p&gt;From the [docs] (/arborCollections/../docs/ ) page, get anolis.phy and anolis.csv.
Load these files into Arbor, and use them as inputs to the aceArbor function. Choose
the “ecomorph” column for analysis, and select type: discrete and method: marginal.&lt;/p&gt;

&lt;h2 id=&quot;arguments&quot;&gt;Arguments&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;table: A data table including species names&lt;/li&gt;
  &lt;li&gt;tree: A phylogenetic tree&lt;/li&gt;
  &lt;li&gt;column: The name of the column to analyze&lt;/li&gt;
  &lt;li&gt;type: The character type
    &lt;ul&gt;
      &lt;li&gt;discrete: a character with a discrete number of states&lt;/li&gt;
      &lt;li&gt;continuous: a continuously varying character&lt;/li&gt;
      &lt;li&gt;fromData: will attempt to determine the data type from the data itself&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;method: specifies the method used to reconstruct ancestral character states
    &lt;ul&gt;
      &lt;li&gt;marginal: marginal ancestral state reconstructions, which reconstruct each node integrating over all possibilities at all other nodes in the tree; this is typically the method used in the literature to reconstruce ACEs&lt;/li&gt;
      &lt;li&gt;joint: joint ancestral reconstructions, which give the configuration of ancestral states that together maximize the likelihood of the data given model parameters&lt;/li&gt;
      &lt;li&gt;mcmc: reconstruct ancestral states using Bayesian MCMC. Note that the discrete version of this doesn’t seem to work, and even if it did work it is not a full MCMC ancestral state method&lt;/li&gt;
      &lt;li&gt;stochastic: create stochastic character map&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;outputs&quot;&gt;Outputs&lt;/h2&gt;
&lt;p&gt;Function outputs a table and a plot with results of the ancestral state reconstruction.&lt;/p&gt;
</description>
        <pubDate>Wed, 10 Jun 2015 00:00:00 +0200</pubDate>
        <link>/arborCollections/arborCollections/collections/phylogeny/ancestral-states/</link>
        <guid isPermaLink="true">/arborCollections/arborCollections/collections/phylogeny/ancestral-states/</guid>
      </item>
    
      <item>
        <title>aceArbor</title>
        <description>&lt;h1 id=&quot;acearbor-function&quot;&gt;aceArbor: function&lt;/h1&gt;

&lt;h3 id=&quot;collection-phylogenies&quot;&gt;collection: phylogenies&lt;/h3&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;aceArbor is a function for carrying out ancestral state reconstruction. It works for
both discrete and continuous variables, and can reconstruct ancestral character states
under both a maximum-likelihood and a Bayesian framework. The function returns results
in two formats: a table of ancestral state estimates for each node in the tree, and a plot
of the results.&lt;/p&gt;

&lt;h2 id=&quot;example&quot;&gt;Example&lt;/h2&gt;

&lt;p&gt;From the [docs] (/arborCollections/../docs/ ) page, get anolis.phy and anolis.csv.
Load these files into Arbor, and use them as inputs to the aceArbor function. Choose
the “ecomorph” column for analysis, and select type: discrete and method: marginal.&lt;/p&gt;

&lt;h2 id=&quot;arguments&quot;&gt;Arguments&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;table: A data table including species names&lt;/li&gt;
  &lt;li&gt;tree: A phylogenetic tree&lt;/li&gt;
  &lt;li&gt;column: The name of the column to analyze&lt;/li&gt;
  &lt;li&gt;type: The character type
    &lt;ul&gt;
      &lt;li&gt;discrete: a character with a discrete number of states&lt;/li&gt;
      &lt;li&gt;continuous: a continuously varying character&lt;/li&gt;
      &lt;li&gt;fromData: will attempt to determine the data type from the data itself&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;method: specifies the method used to reconstruct ancestral character states
    &lt;ul&gt;
      &lt;li&gt;marginal: marginal ancestral state reconstructions, which reconstruct each node integrating over all possibilities at all other nodes in the tree; this is typically the method used in the literature to reconstruce ACEs&lt;/li&gt;
      &lt;li&gt;joint: joint ancestral reconstructions, which give the configuration of ancestral states that together maximize the likelihood of the data given model parameters&lt;/li&gt;
      &lt;li&gt;mcmc: reconstruct ancestral states using Bayesian MCMC. Note that the discrete version of this doesn’t seem to work, and even if it did work it is not a full MCMC ancestral state method&lt;/li&gt;
      &lt;li&gt;stochastic: create stochastic character map&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;outputs&quot;&gt;Outputs&lt;/h2&gt;
&lt;p&gt;Function outputs a table and a plot with results of the ancestral state reconstruction.&lt;/p&gt;
</description>
        <pubDate>Wed, 10 Jun 2015 00:00:00 +0200</pubDate>
        <link>/arborCollections/arborCollections/collections/phylogeny/ancestral-states-2/</link>
        <guid isPermaLink="true">/arborCollections/arborCollections/collections/phylogeny/ancestral-states-2/</guid>
      </item>
    
      <item>
        <title>addColumns</title>
        <description>&lt;h1 id=&quot;addcolumns-function&quot;&gt;addColumns: function&lt;/h1&gt;

&lt;h3 id=&quot;collection-base&quot;&gt;collection: base&lt;/h3&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;addColumns can be used to find the sum of two columns in a data matrix.&lt;/p&gt;

&lt;h2 id=&quot;example&quot;&gt;Example&lt;/h2&gt;

&lt;p&gt;From the [docs] (/arborCollections/../docs/ ) page, get anolis.csv.
Load this files into Arbor, and use it as input to the addColumns function.
Choose “SVL” and “awesomeness” as columnOne and columnTwo, respectively.
Name the outputColumn whatever you want.
The output is a table with all the data from anolis.csv along with a new column that shows the sum of SVL and awesomeness.&lt;/p&gt;

&lt;h2 id=&quot;arguments&quot;&gt;Arguments&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;table: A data table&lt;/li&gt;
  &lt;li&gt;columnOne and columnTwo: The name of the columns to add&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;outputs&quot;&gt;Outputs&lt;/h2&gt;
&lt;p&gt;Function outputs a table with a new column appended to the end.&lt;/p&gt;
</description>
        <pubDate>Wed, 10 Jun 2015 00:00:00 +0200</pubDate>
        <link>/arborCollections/arborCollections/collections/base/addColumns/</link>
        <guid isPermaLink="true">/arborCollections/arborCollections/collections/base/addColumns/</guid>
      </item>
    
      <item>
        <title>Phylogenetic signal</title>
        <description>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=https://arbor.kitware.com/phylogenetic-signal/&quot; /&gt;

&lt;p&gt;You should be automatically forwarded to the easy mode app. If not, click &lt;a href=&quot;https://arbor.kitware.com/phylogenetic-signal/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Wed, 10 Jun 2015 00:00:00 +0200</pubDate>
        <link>/arborCollections/arborCollections/arborapps/phylogenetic-signal/</link>
        <guid isPermaLink="true">/arborCollections/arborCollections/arborapps/phylogenetic-signal/</guid>
      </item>
    
  </channel>
</rss>
