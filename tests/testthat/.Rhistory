if(method=="lambda") {
result<-matrix(unlist(result_raw), ncol=7, byrow=T)
rownames(result) <- colnames(td$dat)
colnames(result) <- c("lnL-lambda0", "lnL-lambdaEst", "chiSqTest", "chiSqP", "aiccLambda0", "aiccLambdaEst", "lambdaEst")
}  else {
result<-matrix(unlist(result_raw), ncol=5, byrow=T)
rownames(result) <- colnames(td$dat)
colnames(result) <- c("K", "var-obs", "var-rnd", "P", "zScore")
}
result_raw
method
# measure phylogenetic signal for all characters in a matrix
# requires all characters of the same type - either continuous or discrete
require(aRbor)
td <- make.treedata(tree, table)
if(charType=="continuous") td <- checkNumeric(td)
if(charType=="discrete") td <- checkFactor(td)
if(charType=="discrete" & method=="K") {
print("error - K is not applicable for discrete characters")
result<-NA
}
# measure phylogenetic signal for all characters in a matrix
# requires all characters of the same type - either continuous or discrete
require(aRbor)
td <- make.treedata(tree, table)
if(charType=="continuous") td <- checkNumeric(td)
if(charType=="discrete") td <- checkFactor(td)
if(charType=="discrete" & method=="K") {
print("error - K is not applicable for discrete characters")
result<-NA
}
if(charType=="discrete" & method=="lambda") {
result_raw <- physigArbor(td, charType="discrete", signalTest="pagelLambda")
}
if(charType=="continuous" & method=="K") {
result_raw <- physigArbor(td, charType="continuous", signalTest="Blomberg")
}
if(charType=="continuous" & method=="lambda") {
result_raw <- physigArbor(td, charType="continuous", signalTest="pagelLambda")
}
if(method=="lambda") {
result<-matrix(unlist(result_raw), ncol=7, byrow=T)
rownames(result) <- colnames(td$dat)
colnames(result) <- c("lnL-lambda0", "lnL-lambdaEst", "chiSqTest", "chiSqP", "aiccLambda0", "aiccLambdaEst", "lambdaEst")
}  else {
result<-matrix(unlist(result_raw), ncol=5, byrow=T)
rownames(result) <- colnames(td$dat)
colnames(result) <- c("K", "var-obs", "var-rnd", "P", "zScore")
}
# measure phylogenetic signal for all characters in a matrix
# requires all characters of the same type - either continuous or discrete
require(aRbor)
td <- make.treedata(tree, table)
if(charType=="continuous") td <- checkNumeric(td)
if(charType=="discrete") td <- checkFactor(td)
if(charType=="discrete" & method=="K") {
error("error - K is not applicable for discrete characters")
result<-NA
}
if(charType=="discrete" & method=="lambda") {
result_raw <- physigArbor(td, charType="discrete", signalTest="pagelLambda")
}
if(charType=="continuous" & method=="K") {
result_raw <- physigArbor(td, charType="continuous", signalTest="Blomberg")
}
if(charType=="continuous" & method=="lambda") {
result_raw <- physigArbor(td, charType="continuous", signalTest="pagelLambda")
}
if(method=="lambda") {
result<-matrix(unlist(result_raw), ncol=7, byrow=T)
rownames(result) <- colnames(td$dat)
colnames(result) <- c("lnL-lambda0", "lnL-lambdaEst", "chiSqTest", "chiSqP", "aiccLambda0", "aiccLambdaEst", "lambdaEst")
}  else {
result<-matrix(unlist(result_raw), ncol=5, byrow=T)
rownames(result) <- colnames(td$dat)
colnames(result) <- c("K", "var-obs", "var-rnd", "P", "zScore")
}
source('~/Desktop/arborworkung/manysignal.R')
# measure phylogenetic signal for all characters in a matrix
# requires all characters of the same type - either continuous or discrete
require(aRbor)
td <- make.treedata(tree, table)
if(charType=="continuous") td <- checkNumeric(td)
if(charType=="discrete") td <- checkFactor(td)
if(charType=="discrete" & method=="K") {
cat("error - K is not applicable for discrete characters\n")
result<-NA
}
if(charType=="discrete" & method=="lambda") {
result_raw <- physigArbor(td, charType="discrete", signalTest="pagelLambda")
}
if(charType=="continuous" & method=="K") {
result_raw <- physigArbor(td, charType="continuous", signalTest="Blomberg")
}
if(charType=="continuous" & method=="lambda") {
result_raw <- physigArbor(td, charType="continuous", signalTest="pagelLambda")
}
if(method=="lambda" & !is.na(result)) {
result<-matrix(unlist(result_raw), ncol=7, byrow=T)
rownames(result) <- colnames(td$dat)
colnames(result) <- c("lnL-lambda0", "lnL-lambdaEst", "chiSqTest", "chiSqP", "aiccLambda0", "aiccLambdaEst", "lambdaEst")
}  else if(!is.na(result)){
result<-matrix(unlist(result_raw), ncol=5, byrow=T)
rownames(result) <- colnames(td$dat)
colnames(result) <- c("K", "var-obs", "var-rnd", "P", "zScore")
}
result
source('~/Desktop/arborworkung/manysignal.R')
method="K"
charType="continuous"
# measure phylogenetic signal for all characters in a matrix
# requires all characters of the same type - either continuous or discrete
require(aRbor)
td <- make.treedata(tree, table)
if(charType=="continuous") td <- checkNumeric(td)
if(charType=="discrete") td <- checkFactor(td)
if(charType=="discrete" & method=="K") {
cat("error - K is not applicable for discrete characters\n")
result<-NA
}
if(charType=="discrete" & method=="lambda") {
result_raw <- physigArbor(td, charType="discrete", signalTest="pagelLambda")
}
if(charType=="continuous" & method=="K") {
result_raw <- physigArbor(td, charType="continuous", signalTest="Blomberg")
}
if(charType=="continuous" & method=="lambda") {
result_raw <- physigArbor(td, charType="continuous", signalTest="pagelLambda")
}
if(method=="lambda" & !is.na(result)) {
result<-matrix(unlist(result_raw), ncol=7, byrow=T)
rownames(result) <- colnames(td$dat)
colnames(result) <- c("lnL-lambda0", "lnL-lambdaEst", "chiSqTest", "chiSqP", "aiccLambda0", "aiccLambdaEst", "lambdaEst")
}  else if(!is.na(result)){
result<-matrix(unlist(result_raw), ncol=5, byrow=T)
rownames(result) <- colnames(td$dat)
colnames(result) <- c("K", "var-obs", "var-rnd", "P", "zScore")
}
result
charType
method
# measure phylogenetic signal for all characters in a matrix
# requires all characters of the same type - either continuous or discrete
require(aRbor)
td <- make.treedata(tree, table)
if(charType=="continuous") td <- checkNumeric(td)
if(charType=="discrete") td <- checkFactor(td)
if(charType=="discrete" & method=="K") {
cat("error - K is not applicable for discrete characters\n")
result<-NA
}
if(charType=="discrete" & method=="lambda") {
result_raw <- physigArbor(td, charType="discrete", signalTest="pagelLambda")
}
if(charType=="continuous" & method=="K") {
result_raw <- physigArbor(td, charType="continuous", signalTest="Blomberg")
}
if(charType=="continuous" & method=="lambda") {
result_raw <- physigArbor(td, charType="continuous", signalTest="pagelLambda")
}
if(method=="lambda" & !is.na(result)) {
result<-matrix(unlist(result_raw), ncol=7, byrow=T)
rownames(result) <- colnames(td$dat)
colnames(result) <- c("lnL-lambda0", "lnL-lambdaEst", "chiSqTest", "chiSqP", "aiccLambda0", "aiccLambdaEst", "lambdaEst")
}  else if(!is.na(result)){
result<-matrix(unlist(result_raw), ncol=5, byrow=T)
rownames(result) <- colnames(td$dat)
colnames(result) <- c("K", "var-obs", "var-rnd", "P", "zScore")
}
source('~/Desktop/arborworkung/manysignal.R')
method="K"
charType="discrete"
source('~/Desktop/arborworkung/manysignal.R')
method="K"
charType="discrete"
# measure phylogenetic signal for all characters in a matrix
# requires all characters of the same type - either continuous or discrete
require(aRbor)
td <- make.treedata(tree, table)
if(charType=="continuous") td <- checkNumeric(td)
if(charType=="discrete") td <- checkFactor(td)
if(charType=="discrete" & method=="K") {
cat("error - K is not applicable for discrete characters\n")
result_raw<-NA
}
if(charType=="discrete" & method=="lambda") {
result_raw <- physigArbor(td, charType="discrete", signalTest="pagelLambda")
}
if(charType=="continuous" & method=="K") {
result_raw <- physigArbor(td, charType="continuous", signalTest="Blomberg")
}
if(charType=="continuous" & method=="lambda") {
result_raw <- physigArbor(td, charType="continuous", signalTest="pagelLambda")
}
if(method=="lambda" & !is.na(result_raw)) {
result<-matrix(unlist(result_raw), ncol=7, byrow=T)
rownames(result) <- colnames(td$dat)
colnames(result) <- c("lnL-lambda0", "lnL-lambdaEst", "chiSqTest", "chiSqP", "aiccLambda0", "aiccLambdaEst", "lambdaEst")
}  else if(!is.na(result_raw)){
result<-matrix(unlist(result_raw), ncol=5, byrow=T)
rownames(result) <- colnames(td$dat)
colnames(result) <- c("K", "var-obs", "var-rnd", "P", "zScore")
}
if(is.na(result_raw)) result<-NA
result
method="K"
charType="continuous"
# measure phylogenetic signal for all characters in a matrix
# requires all characters of the same type - either continuous or discrete
require(aRbor)
td <- make.treedata(tree, table)
if(charType=="continuous") td <- checkNumeric(td)
if(charType=="discrete") td <- checkFactor(td)
if(charType=="discrete" & method=="K") {
cat("error - K is not applicable for discrete characters\n")
result_raw<-NA
}
if(charType=="discrete" & method=="lambda") {
result_raw <- physigArbor(td, charType="discrete", signalTest="pagelLambda")
}
if(charType=="continuous" & method=="K") {
result_raw <- physigArbor(td, charType="continuous", signalTest="Blomberg")
}
if(charType=="continuous" & method=="lambda") {
result_raw <- physigArbor(td, charType="continuous", signalTest="pagelLambda")
}
if(method=="lambda" & !is.na(result_raw)) {
result<-matrix(unlist(result_raw), ncol=7, byrow=T)
rownames(result) <- colnames(td$dat)
colnames(result) <- c("lnL-lambda0", "lnL-lambdaEst", "chiSqTest", "chiSqP", "aiccLambda0", "aiccLambdaEst", "lambdaEst")
}  else if(!is.na(result_raw)){
result<-matrix(unlist(result_raw), ncol=5, byrow=T)
rownames(result) <- colnames(td$dat)
colnames(result) <- c("K", "var-obs", "var-rnd", "P", "zScore")
}
if(is.na(result_raw)) result<-NA
result
source('~/Desktop/arborworkung/manysignal.R')
# measure phylogenetic signal for all characters in a matrix
# requires all characters of the same type - either continuous or discrete
require(aRbor)
td <- make.treedata(tree, table)
if(charType=="continuous") td <- checkNumeric(td)
if(charType=="discrete") td <- checkFactor(td)
error<-F
if(charType=="discrete" & method=="K") {
cat("error - K is not applicable for discrete characters\n")
error<-T
}
if(charType=="discrete" & method=="lambda") {
result_raw <- physigArbor(td, charType="discrete", signalTest="pagelLambda")
}
if(charType=="continuous" & method=="K") {
result_raw <- physigArbor(td, charType="continuous", signalTest="Blomberg")
}
if(charType=="continuous" & method=="lambda") {
result_raw <- physigArbor(td, charType="continuous", signalTest="pagelLambda")
}
if(method=="lambda" & !error) {
result<-matrix(unlist(result_raw), ncol=7, byrow=T)
rownames(result) <- colnames(td$dat)
colnames(result) <- c("lnL-lambda0", "lnL-lambdaEst", "chiSqTest", "chiSqP", "aiccLambda0", "aiccLambdaEst", "lambdaEst")
}  else if(!error){
result<-matrix(unlist(result_raw), ncol=5, byrow=T)
rownames(result) <- colnames(td$dat)
colnames(result) <- c("K", "var-obs", "var-rnd", "P", "zScore")
}
if(error) result<-NA
method="K"
charType="discrete"
# measure phylogenetic signal for all characters in a matrix
# requires all characters of the same type - either continuous or discrete
require(aRbor)
td <- make.treedata(tree, table)
if(charType=="continuous") td <- checkNumeric(td)
if(charType=="discrete") td <- checkFactor(td)
error<-F
if(charType=="discrete" & method=="K") {
cat("error - K is not applicable for discrete characters\n")
error<-T
}
if(charType=="discrete" & method=="lambda") {
result_raw <- physigArbor(td, charType="discrete", signalTest="pagelLambda")
}
if(charType=="continuous" & method=="K") {
result_raw <- physigArbor(td, charType="continuous", signalTest="Blomberg")
}
if(charType=="continuous" & method=="lambda") {
result_raw <- physigArbor(td, charType="continuous", signalTest="pagelLambda")
}
if(method=="lambda" & !error) {
result<-matrix(unlist(result_raw), ncol=7, byrow=T)
rownames(result) <- colnames(td$dat)
colnames(result) <- c("lnL-lambda0", "lnL-lambdaEst", "chiSqTest", "chiSqP", "aiccLambda0", "aiccLambdaEst", "lambdaEst")
}  else if(!error){
result<-matrix(unlist(result_raw), ncol=5, byrow=T)
rownames(result) <- colnames(td$dat)
colnames(result) <- c("K", "var-obs", "var-rnd", "P", "zScore")
}
if(error) result<-NA
result
method="K"
charType="continuous"
# measure phylogenetic signal for all characters in a matrix
# requires all characters of the same type - either continuous or discrete
require(aRbor)
td <- make.treedata(tree, table)
if(charType=="continuous") td <- checkNumeric(td)
if(charType=="discrete") td <- checkFactor(td)
error<-F
if(charType=="discrete" & method=="K") {
cat("error - K is not applicable for discrete characters\n")
error<-T
}
if(charType=="discrete" & method=="lambda") {
result_raw <- physigArbor(td, charType="discrete", signalTest="pagelLambda")
}
if(charType=="continuous" & method=="K") {
result_raw <- physigArbor(td, charType="continuous", signalTest="Blomberg")
}
if(charType=="continuous" & method=="lambda") {
result_raw <- physigArbor(td, charType="continuous", signalTest="pagelLambda")
}
if(method=="lambda" & !error) {
result<-matrix(unlist(result_raw), ncol=7, byrow=T)
rownames(result) <- colnames(td$dat)
colnames(result) <- c("lnL-lambda0", "lnL-lambdaEst", "chiSqTest", "chiSqP", "aiccLambda0", "aiccLambdaEst", "lambdaEst")
}  else if(!error){
result<-matrix(unlist(result_raw), ncol=5, byrow=T)
rownames(result) <- colnames(td$dat)
colnames(result) <- c("K", "var-obs", "var-rnd", "P", "zScore")
}
if(error) result<-NA
result
method="lambda"
charType="discrete"
# measure phylogenetic signal for all characters in a matrix
# requires all characters of the same type - either continuous or discrete
require(aRbor)
td <- make.treedata(tree, table)
if(charType=="continuous") td <- checkNumeric(td)
if(charType=="discrete") td <- checkFactor(td)
error<-F
if(charType=="discrete" & method=="K") {
cat("error - K is not applicable for discrete characters\n")
error<-T
}
if(charType=="discrete" & method=="lambda") {
result_raw <- physigArbor(td, charType="discrete", signalTest="pagelLambda")
}
if(charType=="continuous" & method=="K") {
result_raw <- physigArbor(td, charType="continuous", signalTest="Blomberg")
}
if(charType=="continuous" & method=="lambda") {
result_raw <- physigArbor(td, charType="continuous", signalTest="pagelLambda")
}
if(method=="lambda" & !error) {
result<-matrix(unlist(result_raw), ncol=7, byrow=T)
rownames(result) <- colnames(td$dat)
colnames(result) <- c("lnL-lambda0", "lnL-lambdaEst", "chiSqTest", "chiSqP", "aiccLambda0", "aiccLambdaEst", "lambdaEst")
}  else if(!error){
result<-matrix(unlist(result_raw), ncol=5, byrow=T)
rownames(result) <- colnames(td$dat)
colnames(result) <- c("K", "var-obs", "var-rnd", "P", "zScore")
}
if(error) result<-NA
result
method="lambda"
charType="continuous"
# measure phylogenetic signal for all characters in a matrix
# requires all characters of the same type - either continuous or discrete
require(aRbor)
td <- make.treedata(tree, table)
if(charType=="continuous") td <- checkNumeric(td)
if(charType=="discrete") td <- checkFactor(td)
error<-F
if(charType=="discrete" & method=="K") {
cat("error - K is not applicable for discrete characters\n")
error<-T
}
if(charType=="discrete" & method=="lambda") {
result_raw <- physigArbor(td, charType="discrete", signalTest="pagelLambda")
}
if(charType=="continuous" & method=="K") {
result_raw <- physigArbor(td, charType="continuous", signalTest="Blomberg")
}
if(charType=="continuous" & method=="lambda") {
result_raw <- physigArbor(td, charType="continuous", signalTest="pagelLambda")
}
if(method=="lambda" & !error) {
result<-matrix(unlist(result_raw), ncol=7, byrow=T)
rownames(result) <- colnames(td$dat)
colnames(result) <- c("lnL-lambda0", "lnL-lambdaEst", "chiSqTest", "chiSqP", "aiccLambda0", "aiccLambdaEst", "lambdaEst")
}  else if(!error){
result<-matrix(unlist(result_raw), ncol=5, byrow=T)
rownames(result) <- colnames(td$dat)
colnames(result) <- c("K", "var-obs", "var-rnd", "P", "zScore")
}
if(error) result<-NA
result
##"script": "\n## fitContinuous script\nlibrary(aRbor)\nlibrary(geiger)\nlibrary(cardoonTools)\n\ntd <- make.treedata(tree, table)\ntd <- checkNumeric(td)\nvalid.numeric <- which(colnames(td$dat)==column)\nif(length(valid.numeric)==0){\n  stop(\"The supplied column is not present, or is not a valid continuous trait\")\n}\ntd <- select(td, valid.numeric)\n\no <- fitContinuous(td$phy, td$dat, model=model, SE=0)\nopt = o$opt\n\nif (model == \"OU\") {\n  fit=list(z0.param=opt$z0, sigsq.param=opt$sigsq, alpha.param=opt$alpha, lnL=opt$lnL, AIC=opt$aic, AICc=opt$aicc)\n  result<-rescale(tree, \"OU\", o$opt$alpha)\n} else if (model == \"BM\") {\n  fit=list(z0.param=opt$z0, sigsq.param=opt$sigsq, lnL=opt$lnL, AIC=opt$aic, AICc=opt$aicc)\n  result<-tree\n} else if (model == \"EB\") {\n  fit=list(z0.param=opt$z0, sigsq.param=opt$sigsq, a=opt$a, lnL=opt$lnL, AIC=opt$aic, AICc=opt$aicc)\n  result<-rescale(tree, \"EB\", o$opt$a)\n}\n\ntreePlot = cardoonPlot(expression(plotContrasts(result, setNames(td$dat[[column]], td$phy$tip.label), cex.tip.label=0.5)), width=1000, height=1000, res=100)\ntreePlot = treePlot$png"
##"script": "\n## fitDiscrete script\nlibrary(aRbor)\nlibrary(geiger)\nlibrary(cardoonTools)\n\ntd <- make.treedata(tree, table)\ntd <- checkFactor(td)\nvalid.factor <- which(colnames(td$dat)==column)\nif(length(valid.factor)==0){\n  stop(\"The supplied column is not present, or is not a valid continuous trait\")\n}\ntd <- select(td, valid.factor)\n\no <- fitDiscrete(td$phy, td$dat, model=model)\n\nres = data.frame(lnL = o$opt$lnL, aic = o$opt$aic, aicc = o$opt$aicc, k = o$opt$k)\nQ <- geiger:::.Qmatrix.from.gfit(o)\nQ<-cbind(rownames(Q), Q)\n"
read.csv("~/Downloads/bayesianBisseAnalysis samples (1).csv")
mcmcTable<-read.csv("~/Downloads/bayesianBisseAnalysis samples (1).csv")
generationColumn<-1
## Convert table to mcmc object with generation column removed
if(!is.null(generationColumn)){
plotTable <- mcmcTable[,-generationColumn]
} else {
plotTable <- mcmcTable
}
plotTable
start <- ifelse(burnin==0, 1, floor(burnin*nrow(plotTable)))
plotTable <- plotTable[start:nrow(plotTable),]
burnin<-0
## Exclude burnin sample
start <- ifelse(burnin==0, 1, floor(burnin*nrow(plotTable)))
plotTable <- plotTable[start:nrow(plotTable),]
## Scale the output graphics to the number of parameters
hgt <- 200*ncol(plotTable)
plotTable
tracePlots <- function(table){
par(mfrow=c(ncol(table), 2))
for(i in 1:ncol(table)){
traceplot(coda::mcmc(table[,i]), main=paste(colnames(table)[i], "trace"))
densplot(coda::mcmc(table[,i]), main=paste(colnames(table)[i], "density"))
}
}
tracePlots(plotTable)
require(coda)
tracePlots(plotTable)
tracePlots(plotTable)
nrow(plotTable)/sampleFreq
sampleFreq<-100
nrow(plotTable)/sampleFreq
floor(nrow(plotTable)/sampleFreq)
1:nsamples*sampleFreq
nsamples<-floor(nrow(plotTable)/sampleFreq)
1:nsamples*sampleFreq
tableSamples<-plotTable[1:nsamples*sampleFreq,]
tableSamples
apply(tableSamples, 1, mean)
apply(tableSamples, 2, mean)
result<-numeric(3)
x<-tableSamples[,1]
x
result<-numeric(3)
mean<-mean(x)
mean
result[1]<-mean(x)
result[2]<-quantile(x, 0.95)
quantile
result<-numeric(3)
result[1]<-mean(x)
result[2]<-quantile(x, 0.025)
result[3]<-quantile(x, 0.975)
result
meanAndCI<-function(x) {
result<-numeric(3)
result[1]<-mean(x)
result[2]<-quantile(x, 0.025)
result[3]<-quantile(x, 0.975)
result
}
apply(tableSamples, 2, meanAndCI)
meanAndCI<-function(x) {
result<-numeric(3)
result[2]<-mean(x)
result[1]<-quantile(x, 0.025)
result[3]<-quantile(x, 0.975)
result
}
apply(tableSamples, 2, meanAndCI)
summaryTable<-rbind(colnames(res), res)
summaryTable
res<-apply(tableSamples, 2, meanAndCI)
summaryTable<-rbind(colnames(res), res)
summaryTable
result[2]<-median(x)
meanAndCI<-function(x) {
result<-numeric(3)
result[2]<-median(x)
result[1]<-quantile(x, 0.025)
result[3]<-quantile(x, 0.975)
result
}
res<-apply(tableSamples, 2, meanAndCI)
summaryTable<-cbind(c("param", "lowerCI", "median", "upperCI"), rbind(colnames(res), res))
summaryTable
require(testthat)
setwd("~/Documents/arbor/arborCollections-simple/")
setwd("~/Documents/arbor/arborCollections-simple/test")
setwd("~/Documents/arbor/arborCollections-simple/tests")
setwd("~/Documents/arbor/arborCollections-simple/tests/testthat")
source("../estimateAncestralStates_Rcode.R")
require(testthat)
source("../estimateAncestralStates_Rcode.R")
require(testthat)
source("../estimateAncestralStates_Rcode.R")
install_github("cardoonTools", "hafen")
require(devtools)
install_github("cardoonTools", "hafen")
install_github("hafen/cardoonTools")
require(testthat)
require(cardoonTools)
source("../estimateAncestralStates_Rcode.R")
source("../estimateAncestralStates_Rcode.R")
foo
return(res)
source("../estimateAncestralStates_Rcode.R")
foo
foo()
