{
    "inputs": [
        {
            "description": "input tree for merging with occurrences and morphology",
            "format": "nested",
            "name": "tree",
            "type": "tree"
        },
        {
            "description": "list of species occurrences to match against the tree taxa ",
            "format": "rows",
            "name": "occurrences",
            "type": "table"
        },
        {
            "description": "column header to describe which column to use in taxa name matching process",
            "domain": {
                "format": "column.names",
                "input": "occurrences"
            },
            "format": "text",
            "name": "matchColumn",
            "type": "string"
        },
        {
            "description": "morphology table; should have matching matchColumn key with occurrence table",
            "format": "rows",
            "name": "morphtable",
            "type": "table"
        }
    ],
    "mode": "python",
    "name": "Merge Tree, Occurrences, and Morphology",
    "outputs": [
        {
            "description": "output tree with extra information on the taxa nodes",
            "format": "nested",
            "name": "treeWithLocations",
            "type": "tree"
        },
        {
            "description": "output status of merging process",
            "format": "rows",
            "name": "statusTable",
            "type": "table"
        },
        {
            "description": "output detailed information on individual matches found",
            "format": "rows",
            "name": "matchingTable",
            "type": "table"
        }
    ],
    "script": "#  Phylotree and species occurrence matching analysis\n#  Curtis Lisle\n#  KnowledgeVis, LLC\n\n# Copyright by KnowledgeVis,LLC and Kitware, Inc.\n\n# This analysis step scans through a species occurence table (of the format of Chodon's Heliconia location table) and tries to \n# add as many of these location observations as possible to the taxa of an input phylogenetic tree.  Species name and collection number\n# are used to try to find matches.  The output tree has the locations added as attributes so they can be traversed using phyloTraitMap \n# and support interactive exploration. \n\n# Update History:\n# 10/16/14 - added collection/accession number match column input option (previously hard coded to \"Numb\").  Incorporated unique\n#            nodeids so separate analysis step is not required.\n#\n\n# NOTE: it has been observed with the Heliconia dataset (2014) that occurrences appear to match more than one taxon, because\n# total matches discovered can be greater than the number of occurrence entries. \n\n# inputs\n# ------\n# occurrences - table with the occurrrences one per line\n# matchColumn - column name for column to attempt match in addition to \"species\" \n# tree - tree we want to merge the occurrences into (nested format)\n# morphtable - morphology table with attributes for individuals with index by same matchColumn attribute as the occurrence table\n#\n# outputs\n# -------\n# treeWithLocations - nested format tree with location arrays added to the taxa\n# statusTable - output table showing matches summary counts\n# matchingTable - output detailed matching information\n\ncount = 0\nfoundSpecies = 0\nfoundSpeciesAndCollectorNumber = 0\nfoundCollector = 0\nfoundMorphology = 0\n\nstatusTable = {}\nstatusTable['fields'] = ['description','value']\nstatusTable['rows'] = []\n\nmatchingTable = {}\nmatchingTable['fields'] = ['matchType','occSpecies','occMatch','taxonSpecies','taxonMatch','taxonFullName']\nmatchingTable['rows'] = []\n\nunmatchedTable = {}\nunmatchedTable['fields'] = ['occSpecies','occNumber','collectorNumber','inputTableIndex']\nunmatchedTable['rows'] = []\n\n# have a counter for unique nodeIDs.  the nodes only have to be unique within\n# this tree, so a counter can be used. Initialize with count=1\nnodecount = 1\n\n\n# add an entry to the matching table.  This is called by addLocationsToTaxon to keep records of how matching\n# was performed during the occurrrence & tree matching process\n\ndef makeMatchingEntry(matchtype,occ,taxSpecies,taxColl,tax):\n    global matchingTable\n    row = {}\n    row['matchType'] = matchtype\n    if 'species' in occ:\n        row['occSpecies'] = occ['species']\n    else:\n        row['occSpecies'] = 'NA'\n    row['occMatch'] = occ[matchColumn]\n    row['taxonSpecies'] = taxSpecies\n    row['taxonMatch'] = taxColl\n    row['taxonFullName'] = tax['node_data']['node name']\n    matchingTable['rows'].append(row)\n    \n''' this is currently unused, but it might be nice to list occurrences that didn't match anything    \n# add an entry to the un-matched table.  \ndef makeUnmatchedEntry(occ,index):\n    global unmatchedTable\n    row = {}\n    row['occSpecies'] = occ['species']\n    row['occNumber'] = occ['Numb']\n    row['collectorNumber'] = occ['Collector_Numb']\n    row['inputTableIndex'] = index\n    unmatchedTable['rows'].append(row)\n'''\n    \n# this routine looks through the occurrence data to find a matches for a particular taxon and adds the location\n# information as a new list attribute 'loc' on each taxon where observations are mapped.  Mapping occurs first when\n# there are both species and collector matches.  Then if there is no match on species and collector, collection only is used to match\n# as a second option, finally species only is used. \n# Records of the matching process are output in the \"matchingTable\" output of this step. \n\ndef addLocationsToTaxon(taxon): \n    global occurrences\n    global foundSpeciesAndCollectorNumber\n    global foundSpecies\n    global foundCollector\n    global inputTableIndex\n    #some taxon names are in single quotes because of a dot in the name, \n    # i.e. 'standleyi_L80,0894', so remove the single quotes\n    noquotes = taxon['node_data']['node name'].replace(\"'\",\"\")\n    # separate species from collector number by looking for the '_' used between species and number\n    components = noquotes.split(\"_\")\n    taxon_species = components[0]\n    taxon_collector = components[1]\n    #print \"found taxon:\",taxon_species,taxon_collector\n    # now look for matches\n    for occurrence in occurrences['rows']:\n        if (occurrence[matchColumn]==taxon_collector) and (occurrence['species'] == taxon_species):\n            #print \"found match between occurrence:\",occurrence['Numb'], \"and \",noquotes\n            foundSpeciesAndCollectorNumber = foundSpeciesAndCollectorNumber+1\n            #if this is the first occurrence found, create a new list, otherwise add to the existing list\n            if 'loc' in taxon['node_data'].keys():\n                taxon['node_data']['loc'].append([occurrence['long'],occurrence['lat']])\n            else:\n                taxon['node_data']['loc'] = [[occurrence['long'],occurrence['lat']]]\n            # add the collector column entry to the taxon record so we can cross reference with morphology later\n            attribRecord = {}\n            attribRecord[matchColumn] = occurrence[matchColumn]\n            if 'attributes' in taxon['node_data'].keys():\n                taxon['node_data']['attributes'].append(attribRecord)\n            else:\n                taxon['node_data']['attributes'] = [attribRecord]\n            makeMatchingEntry('both',occurrence,taxon_species,taxon_collector,taxon)\n        elif (occurrence['species'] == taxon_species):\n            foundSpecies = foundSpecies+1            \n            #if this is the first occurrence found, create a new list, otherwise add to the existing list\n            if 'loc' in taxon['node_data'].keys():\n                taxon['node_data']['loc'].append([occurrence['long'],occurrence['lat']])\n            else:\n                taxon['node_data']['loc'] = [[occurrence['long'],occurrence['lat']]]\n            # add the collector column entry to the taxon record so we can cross reference with morphology later\n            attribRecord = {}\n            attribRecord[matchColumn] = occurrence[matchColumn]\n            if 'attributes' in taxon['node_data'].keys():\n                taxon['node_data']['attributes'].append(attribRecord)\n            else:\n                taxon['node_data']['attributes'] = [attribRecord]\n            makeMatchingEntry('species',occurrence,taxon_species,taxon_collector,taxon)\n\n\n# look through the morph matrix and return a row that matches the search key (e.g. particular value for field 'Numb')\n# if there is no matching key records in the morph table, return no matches.  \n\ndef returnMatchingMorphRecord(searchkey):\n    global morphtable\n    for row in morphtable['rows']:\n        # only continue if there is a matching header in the morph table\n        if matchColumn in row.keys():\n            if row[matchColumn] == searchkey:\n                return {'status': True, 'data': row}\n    return  {'status': False}\n            \n\n# this routine looks through the morphology matrix for key matches to the attribute added to the taxon.\n# all matching attributes are added to the 'attributes' list stored at the taxon level. The taxon 'attributes'\n# list has a list of records, each corresponding to a single occurrence that was matched to the taxon. In this \n# method, we simply find a matching record in the morphology table and copy the attribute columns into the taxon\n# node of the tree to \"flush out\" the tree with trait data for later analysis and visualization\n\ndef addMorphologyToTaxon(taxon):\n    global foundMorphology\n    if 'attributes' in taxon['node_data'].keys():\n        # loop through each occurrence record and expand the attribute record from just the number to include attributes\n        for attribRecord in taxon['node_data']['attributes']:\n            morphRecord = returnMatchingMorphRecord(attribRecord[matchColumn])\n            if morphRecord['status']:\n                foundMorphology += 1\n                # rebuild the components of the taxon name for the reporting\n                noquotes = taxon['node_data']['node name'].replace(\"'\",\"\")\n                components = noquotes.split(\"_\")\n                taxon_species = components[0]\n                taxon_collector = components[1]\n                makeMatchingEntry('morph',morphRecord['data'],taxon_species,taxon_collector,taxon)\n                #print morphRecord['data']\n                for attrib in morphRecord['data']:\n                    # store all records besides the key, because we have that already\n                    if attrib != matchColumn:\n                        attribRecord[attrib] = morphRecord['data'][attrib]\n  \n\n# -------- top level methods below --------------------\n\n# this routine traverses a phylo tree in nested format and add lat,long from\n# the occurrence records to the node.  This is the top level of the recursive traversal of the tree. Traversal\n# starts from the top and continues past the intermediate nodes,  for each taxon reached, addLocationsToTaxon is called\n# a single time to possibly add any matching occurrences to the taxon's attributes\n\ndef addLocationsToTreeNodes(treenode):\n    # look at the current tree node and see if there are children or not\n    if 'children' in treenode.keys():\n        #case for a hierarchy node, traverse to all the children\n        for node in treenode['children']:\n            addLocationsToTreeNodes(node)\n    else:\n        #case for a taxa. Look through the occurrence and add records to \n        # this node\n        addLocationsToTaxon(treenode)\n        \n        \n# this routine traverses a phylo tree in nested format and adds attributes from\n# the morphology matrix to the taxa nodes.  This should be run AFTER the \n# locations traversal because it relies on the matchColumn value (the ascension or \n# collection index number) to be present in the taxon node.  This traversal\n# could be combined with the location/match traversal for improved speed, but \n# this separate traversal is simpler in design.\n\ndef addMorphologyToTreeNodes(treenode):\n    # look at the current tree node and see if there are children or not\n    if 'children' in treenode.keys():\n        #case for a hierarchy node, traverse to all the children\n        for node in treenode['children']:\n            addMorphologyToTreeNodes(node)\n    else:\n        #case for a taxa. Look through the occurrence and add records to \n        # this node\n        addMorphologyToTaxon(treenode)        \n\n\n\n# this routine traverses a phylo tree in nested format. Add a nodeid and then\n# increment the count every time we encounter a node during a depth first search\n\ndef addUniqueIDsToTreeNodes(treenode):\n    global nodecount\n    treenode['node_data']['nodeid'] = nodecount\n    nodecount += 1\n    # look at the current tree node and see if there are children or not\n    if 'children' in treenode.keys():\n        #case for a hierarchy node, traverse to all the children\n        for node in treenode['children']:\n            addUniqueIDsToTreeNodes(node)\n        \n    \n# here are the top level actions, add locations and output the tree\naddLocationsToTreeNodes(tree)\naddMorphologyToTreeNodes(tree)\naddUniqueIDsToTreeNodes(tree)\ntreeWithLocations = tree\n\n#print \"species and collector matches:\",foundSpeciesAndCollectorNumber\n#print \"species matches:\",foundSpecies\n\n# output status records\nstatusTable['rows'].append({'description': 'total occurrence records','value': len(occurrences['rows'])})\nstatusTable['rows'].append({'description': 'species and collection matches','value':foundSpeciesAndCollectorNumber})\nstatusTable['rows'].append({'description': 'collection only matches','value':foundCollector})\nstatusTable['rows'].append({'description': 'species only matches','value':foundSpecies})\nstatusTable['rows'].append({'description': 'morphology records merged','value':foundMorphology})\n\n\n"
}