{
    "description": "",
    "inputs": [
        {
            "format": "nested",
            "id": "tree",
            "name": "tree",
            "type": "tree"
        },
        {
            "format": "rows",
            "id": "matrix",
            "name": "matrix",
            "type": "table"
        },
        {
            "format": "text",
            "id": "outfilename",
            "name": "outfilename",
            "type": "string"
        }
    ],
    "mode": "python",
    "name": "Hierarchical Heatmap with Metadata",
    "outputs": [],
    "script": "#\n# Create a hierarchical Heatmap input file from a tree and matrix.  An output table\n# is created containing the pathname to \n#\n# Author: C. Lisle; KnowledgeVis\n#\n\n# inputs:\n# tree - phylotree\n# matrix - matrix with 'name' column that matches the tree tips\n#\n\n# the purpose of this method is to receive a dictionary as a parameter, which corresponds to one of\n# the rows in the trait matrix.  We will then generate a list of the trait values in the order that \n# matches the matrix['fields'] list.  This list wil be added to the leaf node of the hierarchy output for InCHlib.\n\ndef returnRowAsListInFeatureOrder(row):\n    global matrix\n    outlist = []\n    for field in matrix['fields']: \n        #if field not in ['taxa','name','species']:\n            #print 'appending', field,' of row:', row\n        #    outlist.append(row[field])\n        outlist.append(row[field])\n    return outlist\n    \n    \n# this routine runs through the matrix, looking for a row with a matching taxon name.\n# it returns the row if a match is found, and an empty dictionary otherwise.\n\ndef findMatchingMatrixRow(name):\n    global matrix\n    record = {'taxa':''}\n    for row in matrix['rows']:\n        if ('name' in row) and (row['name'] == name):\n            return returnRowAsListInFeatureOrder(row)\n        elif ('taxa' in row) and (row['taxa'] == name):\n            return returnRowAsListInFeatureOrder(row)\n        elif ('species' in row) and (row['species'] == name):\n            return returnRowAsListInFeatureOrder(row)\n    return []\n\ndef addMorphologyToTaxon(treenode):\n    pass\n\n# some trees may have a 'nodeid' field already, but lets make sure there is a node name and just use the node name \n# for the hierarhical construction. \n\nnodeCounter = 1\ndef assignNodeNamesandHeights(treenode):\n    global nodeCounter\n    # assign a name if the node doesn't have one\n    if ('node name' not in treenode['node_data']) or (len(treenode['node_data']['node name']) == 0):\n        treenode['node_data']['node name'] = 'node'+str(nodeCounter)\n        \n    # look at the current tree node and see if there are children or not\n    if 'children' in treenode.keys():\n        height = []\n        count = []\n        #case for a hierarchy node, traverse to all the children, combine their height\n        for node in treenode['children']:\n            nodeCounter += 1\n            childsubtree = assignNodeNamesandHeights(node)\n            height.append(childsubtree['height'])\n            count.append(childsubtree['count'])\n            \n        # set this node to be one higher than the highest child\n        treenode['node_data']['height'] = max(height) + 1\n        # count means how many leaves below this. this node is above all leaves in both subtrees\n        treenode['node_data']['count'] = sum(count)\n        return treenode['node_data']\n    else:\n        #case for a taxa. Look through the occurrence and add records to \n        # this node and return a fixed height of 1 (to match examples)\n        #addMorphologyToTaxon(treenode)\n        treenode['node_data']['height'] =  1\n        treenode['node_data']['count'] = 1\n        return treenode['node_data']\n\ndef writeTreeTipsToOutput(treenode,parent):\n    global outdata\n    #print 'writing: ',treenode['node_data']['node name']\n    if 'children' in treenode.keys():\n        for child in treenode['children']:\n            # write child record\n            writeTreeTipsToOutput(child,treenode['node_data']['node name'])\n    else:\n        # we are a child node, write out the record but don't recurse farther\n        outdata['data']['nodes'][treenode['node_data']['node name']] = {}\n        outdata['data']['nodes'][treenode['node_data']['node name']]['count'] = treenode['node_data']['count']\n        outdata['data']['nodes'][treenode['node_data']['node name']]['distance'] = 0       \n        outdata['data']['nodes'][treenode['node_data']['node name']]['parent'] = parent\n        outdata['data']['nodes'][treenode['node_data']['node name']]['features'] = findMatchingMatrixRow(treenode['node_data']['node name'])\n        outdata['data']['nodes'][treenode['node_data']['node name']]['objects'] = ['object id']\n        if parent != 'null':\n            outdata['data']['nodes'][treenode['node_data']['node name']]['parent'] = parent\n\n\n\ndef writeTreeHierarchyToOutput(treenode,parent):\n    global outdata\n    #print 'writing: ',treenode['node_data']['node name']\n    if 'children' in treenode.keys():\n        for child in treenode['children']:\n            # write child record\n            writeTreeHierarchyToOutput(child,treenode['node_data']['node name'])\n        # now write out a hierarchy node\n        outdata['data']['nodes'][treenode['node_data']['node name']] = {}\n        outdata['data']['nodes'][treenode['node_data']['node name']]['count'] = treenode['node_data']['count']\n        \n        # if the tree has branch lengths, then use these lengths as the scaling instead of the height. This didn't\n        # work reliably because we can't control the scaling between different datasets without more sophisticated\n        # treatment of the scale.  Has been disabled for now.\n        #if 'edge_data' in treenode:\n        #    if 'weight' in treenode['edge_data']:\n        #        outdata['data']['nodes'][treenode['node_data']['node name']]['distance'] = treenode['edge_data']['weight']\n        #    else:\n        #        outdata['data']['nodes'][treenode['node_data']['node name']]['distance'] = treenode['node_data']['height']\n        outdata['data']['nodes'][treenode['node_data']['node name']]['distance'] = treenode['node_data']['height']\n        \n        outdata['data']['nodes'][treenode['node_data']['node name']]['left_child'] = treenode['children'][0]['node_data']['node name']\n        outdata['data']['nodes'][treenode['node_data']['node name']]['right_child'] = treenode['children'][1]['node_data']['node name']\n        # put a parent field unless this is the tree root\n        if parent != 'null':\n            outdata['data']['nodes'][treenode['node_data']['node name']]['parent'] = parent   \n\n# traverse the hierarchy and make a flat list of taxa nodenames\nglobalTaxonList = []\ndef makeTaxonList(treenode):\n    global globalTaxonList\n    if 'children' in treenode.keys():\n        for child in treenode['children']:\n            # write child record\n            makeTaxonList(child)\n    else:\n        # we are a child node, write out the record but don't recurse farther\n        globalTaxonList.append(treenode['node_data']['node name'])\n    \n\n# this routine goes through the columns of the matrix and writes out the attributes (except for the taxon name)\ndef fillInFeaturesList(matrix):\n    for field in matrix['fields']:\n        #if field not in ['taxa','name','species']:\n        #    outdata['data']['feature_names'].append(field)\n        outdata['data']['feature_names'].append(field)            \n\n# spin through the trait matrix and add the taxa names to the metadata field in the output\ndef addNamesToMetadata(matrix):\n    global outdata\n    outdata['metadata'] = {}\n    outdata['metadata']['features_names'] = []\n    outdata['metadata']['features_names'].append('name')\n    outdata['metadata']['nodes'] = {}\n    makeTaxonList(outtree)\n    for name in globalTaxonList:\n        outdata['metadata']['nodes'][name] = [name]\n    \n        \n# ------ top level routines --------\n\noutdata = {}\noutdata['data'] = {}\noutdata['data']['nodes'] = {}\noutdata['data']['feature_names'] = []\n#outdata['metadata'] = {}\n#outdata['column_dendrogram'] = {}\n#outdata['column_metadata'] = {}\n#outdata['alternative_data'] = {}\n\n\nouttree = tree\nassignNodeNamesandHeights(outtree)\nwriteTreeTipsToOutput(outtree,'null')\nwriteTreeHierarchyToOutput(outtree,'null')\nfillInFeaturesList(matrix)\naddNamesToMetadata(matrix)\n\n# write to a file since we don't have unstructured JSON in Arbor yet\n\nimport json\nimport io\nwith open(outfilename, 'w') as outfile:\n    json.dump(outdata, outfile)\n\n\n\n\n\n\n"
}