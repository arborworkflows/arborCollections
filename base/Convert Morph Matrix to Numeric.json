{
    "inputs": [
        {
            "format": "rows",
            "name": "table",
            "type": "table"
        },
        {
            "description": "table with columnHeader header of fields to prevent history substitution",
            "format": "rows",
            "name": "columnsToIgnore",
            "type": "table"
        }
    ],
    "mode": "python",
    "name": "Convert Morph Matrix to Numeric",
    "outputs": [
        {
            "description": "records of how codes correspond to original values",
            "format": "rows",
            "name": "legend",
            "type": "table"
        },
        {
            "description": "output table (fully numeric)",
            "format": "rows",
            "name": "outtable",
            "type": "table"
        }
    ],
    "script": "#\n# input: table (a character matrix with a mix of numeric and textual cell entries\n# output: outtable (a matrix where all textual entries have been converted to integers)\n# output: status  (a table describing the processing of the matrix)\n# output: legend (a table that indicates what the integer code means for each value in each column\n#\n\n# algorithm:\n# a dictionary for each input column is maintained.  The dictionary keys are the integers assigned, the values \n# are the original cell values.  This way, this output table can be used as a lookup to restore the table or display \n# with the original entries.  The algorithm uses two passes.  During the first pass, a matching integer code is created for each\n# unique value encountered in each column.  During the second pass, the output table is generated using codes read out from the history\n# mechanism.\n\nstatusTable = {}\nstatusTable['fields'] = ['description','value']\nstatusTable['rows'] = []\n\nlegend = {}\nlegend['fields'] = ['column','original','code']\nlegend['rows'] = []\n\n# values in these columns are not replaced with numeric values\nnameColumns = ['name','species','SPECIES','Species','Scientific Name','scientific name']\n\nuniqueValueCount = 0\n\n# loop through the columnsToIgnore table and collect the names of columns we want to preserve in the output without history substitution\nignorefields = []\nfor row in columnsToIgnore['rows']:\n    ignorefields.append(row['columnHeader'])\n    \n    \n# helper function to check for numberic values only \ndef isNumber(s):\n    try:\n        float(s)\n        return True\n    except ValueError:\n        return False\n\n# this routine initializes the history mechanism to have an entry for each column in the input table. Records\n# will be added to each column's dictionary later.\n\nmatchingDict = {}\ndef initEmptyHistory():   \n    global matchingDict\n    matchingDict = {}\n    for column in table['fields']:\n        # start with an empty dictionary for each column\n        matchingDict[column] = {}\n        \n# if a particular entry is already in the dictionary, return True.  Otherwise return False. \ndef entryInHistory(column,value):\n    try:\n        x = matchingDict[column][value]\n        return True\n    except:\n        return False\n    \n    \n# during the first pass through the table, this routine is called to create new codes and \n# store them in a history mechanism (the matchingDict).  The history will be used to output the \n# translated table during the second pass\n\ndef makeHistoryEntry(column,value):\n    global legend\n    global matchingDict\n    global uniqueValueCount\n    newCode = len(matchingDict[column])\n    row = {}\n    row['column'] = column\n    row['original'] = value\n    row['code'] = newCode\n    # store a code in the matching dictionary for this new unique column value\n    matchingDict[column][value] = newCode\n    legend['rows'].append(row)\n    # count how many entries we have overall\n    uniqueValueCount += 1\n\n# return an entry from the history mechanism\ndef getHistory(column,value):\n    global matchingDict\n    return matchingDict[column][value]\n\n# Below is the main loop of the algorithm.  Each pass is listed below.  The first pass accumulates, the second pass \n# generates the output table using numerical code substitution so the output is a purely numerical table. \n\n# First pass: go through the table, record each unique value and assign a code to it.\ninitEmptyHistory()  \nfor row in table['rows']:\n    for column in row:\n        if (column not in ignorefields):\n            if ( not isNumber(row[column]) and not entryInHistory(column,row[column]) and (column not in nameColumns)):\n                # this entry is not a number but is not yet in the history, so add it\n                #print 'adding',row[column],'to history for',column\n                makeHistoryEntry(column,row[column])\n\n# prepare output table with same schema as input table, but empty\nouttable = {}\nouttable['fields'] = table['fields']\nouttable['rows'] = []\n\n# second pass: output numerically coded table\nfor row in table['rows']:\n    outrow = {}\n    for column in row:\n        if entryInHistory(column,row[column]):\n            # if entry in history, substitute for coded value\n            outrow[column] = getHistory(column,row[column])\n        else:\n            # copy original value, this wasn't coded during pass one\n            outrow[column] = row[column]\n    outtable['rows'].append(outrow)    \n\nstatusTable['rows'].append({'description': 'total coding records','value': uniqueValueCount})\n\n            \n            \n            \n"
}