{
    "inputs": [
        {
            "description": "table with collector number, species, and lat,long column indicating where a species has been observed",
            "format": "rows",
            "name": "occurrences",
            "type": "table"
        },
        {
            "description": "phylotree in nested format with matching taxa names to an occurrence table",
            "format": "nested",
            "name": "tree",
            "type": "tree"
        },
        {
            "default": "Numb",
            "description": "column header to use  as the \"collection number\" to attempt match between tree and matrix",
            "domain": {
                "format": "column.names",
                "input": "occurrences"
            },
            "format": "text",
            "name": "matchColumn",
            "type": "string"
        }
    ],
    "mode": "python",
    "name": "Merge Occurrences Into Tree",
    "outputs": [
        {
            "description": "tree containing ['loc'] lists in the taxa to show where observations have occurred",
            "format": "nested",
            "name": "treeWithLocations",
            "type": "tree"
        },
        {
            "description": "output matching information to see how names and collection numbers matched",
            "format": "rows",
            "name": "statusTable",
            "type": "table"
        },
        {
            "description": "detailing matching information",
            "format": "rows",
            "name": "matchingTable",
            "type": "table"
        }
    ],
    "script": "#  Phylotree and species occurrence matching analysis\n#  Curtis Lisle\n#  KnowledgeVis, LLC\n\n# Copyright by KnowledgeVis,LLC and Kitware, Inc.\n\n# This analysis step scans through a species occurence table (of the format of Chodon's Heliconia location table) and tries to \n# add as many of these location observations as possible to the taxa of an input phylogenetic tree.  Species name and collection number\n# are used to try to find matches.  The output tree has the locations added as attributes so they can be traversed using phyloTraitMap \n# and support interactive exploration. \n\n# Update History:\n# 10/16/14 - added collection/accession number match column input option (previously hard coded to \"Numb\").  Incorporated unique\n#            nodeids so separate analysis step is not required.\n#\n\n# NOTE: it has been observed with the Heliconia dataset (2014) that occurrences appear to match more than one taxon, because\n# total matches discovered can be greater than the number of occurrence entries. \n\n# inputs\n# ------\n# occurrences - table with the occurrrences one per line\n# matchColumn - column name for column to attempt match in addition to \"species\" \n# tree - tree we want to merge the occurrences into (nested format)\n#\n# outputs\n# -------\n# treeWithLocations - nested format tree with location arrays added to the taxa\n# statusTable - output table showing matches summary counts\n# matchingTable - output detailed matching information\n\ncount = 0\nfoundSpecies = 0\nfoundSpeciesAndCollectorNumber = 0\nfoundCollector = 0\n\nstatusTable = {}\nstatusTable['fields'] = ['description','value']\nstatusTable['rows'] = []\n\nmatchingTable = {}\nmatchingTable['fields'] = ['matchType','occSpecies','occMatch','taxonSpecies','taxonMatch','taxonFullName']\nmatchingTable['rows'] = []\n\nunmatchedTable = {}\nunmatchedTable['fields'] = ['occSpecies','occNumber','collectorNumber','inputTableIndex']\nunmatchedTable['rows'] = []\n\n# have a counter for unique nodeIDs.  the nodes only have to be unique within\n# this tree, so a counter can be used. Initialize with count=1\nnodecount = 1\n\n# this routine traverses a phylo tree in nested format and add lat,long from\n# the occurrence records to the node.  This is the top level of the recursive traversal of the tree. Traversal\n# starts from the top and continues past the intermediate nodes,  for each taxon reached, addLocationsToTaxon is called\n# a single time to possibly add any matching occurrences to the taxon's attributes\n\ndef addLocationsToTreeNodes(treenode):\n    # look at the current tree node and see if there are children or not\n    if 'children' in treenode.keys():\n        #case for a hierarchy node, traverse to all the children\n        for node in treenode['children']:\n            addLocationsToTreeNodes(node)\n    else:\n        #case for a taxa. Look through the occurrence and add records to \n        # this node\n        addLocationsToTaxon(treenode)\n\n# add an entry to the matching table.  This is called by addLocationsToTaxon to keep records of how matching\n# was performed during the occurrrence & tree matching process\n\ndef makeMatchingEntry(matchtype,occ,taxSpecies,taxColl,tax):\n    global matchingTable\n    row = {}\n    row['matchType'] = matchtype\n    row['occSpecies'] = occ['species']\n    row['occMatch'] = occ[matchColumn]\n    row['taxonSpecies'] = taxSpecies\n    row['taxonMatch'] = taxColl\n    row['taxonFullName'] = tax['node_data']['node name']\n    matchingTable['rows'].append(row)\n    \n''' this is currently unused, but it might be nice to list occurrences that didn't match anything    \n# add an entry to the un-matched table.  \ndef makeUnmatchedEntry(occ,index):\n    global unmatchedTable\n    row = {}\n    row['occSpecies'] = occ['species']\n    row['occNumber'] = occ['Numb']\n    row['collectorNumber'] = occ['Collector_Numb']\n    row['inputTableIndex'] = index\n    unmatchedTable['rows'].append(row)\n'''\n    \n# this routine looks through the occurrence data to find a matches for a particular taxon and adds the location\n# information as a new list attribute 'loc' on each taxon where observations are mapped.  Mapping occurs first when\n# there are both species and collector matches.  Then if there is no match on species and collector, collection only is used to match\n# as a second option, finally species only is used. \n# Records of the matching process are output in the \"matchingTable\" output of this step. \n\ndef addLocationsToTaxon(taxon): \n    global occurrences\n    global foundSpeciesAndCollectorNumber\n    global foundSpecies\n    global foundCollector\n    global inputTableIndex\n    #some taxon names are in single quotes because of a dot in the name, \n    # i.e. 'standleyi_L80,0894', so remove the single quotes\n    noquotes = taxon['node_data']['node name'].replace(\"'\",\"\")\n    # separate species from collector number by looking for the '_' used between species and number\n    components = noquotes.split(\"_\")\n    taxon_species = components[0]\n    taxon_collector = components[1]\n    #print \"found taxon:\",taxon_species,taxon_collector\n    # now look for matches\n    for occurrence in occurrences['rows']:\n        if (occurrence[matchColumn]==taxon_collector) and (occurrence['species'] == taxon_species):\n            #print \"found match between occurrence:\",occurrence['Numb'], \"and \",noquotes\n            foundSpeciesAndCollectorNumber = foundSpeciesAndCollectorNumber+1\n            #if this is the first occurrence found, create a new list, otherwise add to the existing list\n            if 'loc' in taxon['node_data'].keys():\n                taxon['node_data']['loc'].append([occurrence['long'],occurrence['lat']])\n            else:\n                taxon['node_data']['loc'] = [[occurrence['long'],occurrence['lat']]]\n            # add the collector column entry to the taxon record so we can cross reference with morphology later\n            attribRecord = {}\n            attribRecord[matchColumn] = occurrence[matchColumn]\n            if 'attributes' in taxon['node_data'].keys():\n                taxon['node_data']['attributes'].append(attribRecord)\n            else:\n                taxon['node_data']['attributes'] = [attribRecord]\n            makeMatchingEntry('both',occurrence,taxon_species,taxon_collector,taxon)\n            # comment out the central case because number could be duplicate across different collectors\n'''        elif (occurrence[matchColumn] == taxon_collector):\n            foundCollector = foundCollector+1\n            #if this is the first occurrence found, create a new list, otherwise add to the existing list\n            if 'loc' in taxon['node_data'].keys():\n                taxon['node_data']['loc'].append([occurrence['long'],occurrence['lat']])\n            else:\n                taxon['node_data']['loc'] = [[occurrence['long'],occurrence['lat']]]\n            # add the collector column entry to the taxon record so we can cross reference with morphology later\n            attribRecord = {}\n            attribRecord[matchColumn] = occurrence[matchColumn]\n            if 'attributes' in taxon['node_data'].keys():\n                taxon['node_data']['attributes'].append(attribRecord)\n            else:\n                taxon['node_data']['attributes'] = [attribRecord]\n            makeMatchingEntry('collector',occurrence,taxon_species,taxon_collector,taxon)\n'''\n        elif (occurrence['species'] == taxon_species):\n            foundSpecies = foundSpecies+1            \n            #if this is the first occurrence found, create a new list, otherwise add to the existing list\n            if 'loc' in taxon['node_data'].keys():\n                taxon['node_data']['loc'].append([occurrence['long'],occurrence['lat']])\n            else:\n                taxon['node_data']['loc'] = [[occurrence['long'],occurrence['lat']]]\n            # add the collector column entry to the taxon record so we can cross reference with morphology later\n            attribRecord = {}\n            attribRecord[matchColumn] = occurrence[matchColumn]\n            if 'attributes' in taxon['node_data'].keys():\n                taxon['node_data']['attributes'].append(attribRecord)\n            else:\n                taxon['node_data']['attributes'] = [attribRecord]\n            makeMatchingEntry('species',occurrence,taxon_species,taxon_collector,taxon)\n\n\n\n# this routine traverses a phylo tree in nested format. Add a nodeid and then\n# increment the count every time we encounter a node during a depth first search\n\ndef addUniqueIDsToTreeNodes(treenode):\n    global nodecount\n    treenode['node_data']['nodeid'] = nodecount\n    nodecount += 1\n    # look at the current tree node and see if there are children or not\n    if 'children' in treenode.keys():\n        #case for a hierarchy node, traverse to all the children\n        for node in treenode['children']:\n            addUniqueIDsToTreeNodes(node)\n        \n    \n# here are the top level actions, add locations and output the tree\naddLocationsToTreeNodes(tree)\naddUniqueIDsToTreeNodes(tree)\ntreeWithLocations = tree\n\n#print \"species and collector matches:\",foundSpeciesAndCollectorNumber\n#print \"species matches:\",foundSpecies\n\n# output status records\nstatusTable['rows'].append({'description': 'total occurrence records','value': len(occurrences['rows'])})\nstatusTable['rows'].append({'description': 'species and collection matches','value':foundSpeciesAndCollectorNumber})\nstatusTable['rows'].append({'description': 'collection only matches','value':foundCollector})\nstatusTable['rows'].append({'description': 'species only matches','value':foundSpecies})\n\n\n\n"
}