{
    "inputs": [
        {
            "description": "table with locations and species names",
            "format": "rows",
            "name": "occurrences",
            "type": "table"
        },
        {
            "description": "tree in nested - data will be added to taxon nodes",
            "format": "nested",
            "name": "tree",
            "type": "tree"
        }
    ],
    "mode": "python",
    "name": "TreeLocMatch",
    "outputs": [
        {
            "description": "tree with location data in the taxa nodes",
            "format": "nested",
            "name": "treeWithLocations",
            "type": "tree"
        },
        {
            "description": "output status messages",
            "format": "rows",
            "name": "statusTable",
            "type": "table"
        },
        {
            "description": "output info on name matching progress between tree and locations",
            "format": "rows",
            "name": "matchingTable",
            "type": "table"
        }
    ],
    "script": "#  Phylotree and species occurrence matching analysis\n#  Curtis Lisle\n#  KnowledgeVis, LLC\n\n# Copyright by KnowledgeVis,LLC and Kitware, Inc.\n\n# This analysis step scans through a species occurence table (of the format of Chodon's Heliconia location table) and tries to \n# add as many of these location observations as possible to the taxa of an input phylogenetic tree.  Species name and collection number\n# are used to try to find matches.  The output tree has the locations added as attributes so they can be traversed using phyloTraitMap \n# and support interactive exploration. \n\n# Update History:\n# 10/16/14 - added collection/accession number match column input option (previously hard coded to \"Numb\").  Incorporated unique\n#            nodeids so separate analysis step is not required.\n# 03/20/15 CRL - adapted for Costus dataset\n#\n\n# NOTE: it has been observed with the Heliconia dataset (2014) that occurrences appear to match more than one taxon, because\n# total matches discovered can be greater than the number of occurrence entries. \n\n# inputs\n# ------\n# occurrences - table with the occurrrences one per line\n# matchColumn - column name for column to attempt match in addition to \"species\" \n# tree - tree we want to merge the occurrences into (nested format)\n#\n# outputs\n# -------\n# treeWithLocations - nested format tree with location arrays added to the taxa\n# statusTable - output table showing matches summary counts\n# matchingTable - output detailed matching information\n\ncount = 0\nfoundSpecies = 0\nfoundSpeciesAndCollectorNumber = 0\nfoundCollector = 0\nfoundMorphology = 0\n\nstatusTable = {}\nstatusTable['fields'] = ['description','value']\nstatusTable['rows'] = []\n\nmatchingTable = {}\nmatchingTable['fields'] = ['species','count']\nmatchingTable['rows'] = []\n\n# have a counter for unique nodeIDs.  the nodes only have to be unique within\n# this tree, so a counter can be used. Initialize with count=1\nnodecount = 1\n\ndebug = ''\n\n# add an entry to the matching table for this taxon. \n\ndef outputMatchesForTaxon(taxon):\n    global matchingTable\n    row = {}\n    # output the name of this species\n    row['species'] = taxon['node_data']['node name']\n    # look into how many occurrences matched this species\n    if 'loc' in taxon['node_data'].keys():\n        row['count'] = len(taxon['node_data']['loc'])\n    else:\n        row['count'] = 0\n    matchingTable['rows'].append(row)\n    \n    \n# this routine looks through the occurrence data to find a matches for a particular taxon and adds the location\n# information as a new list attribute 'loc' on each taxon where observations are mapped.  Mapping occurs first when\n# there are both species and collector matches.  Then if there is no match on species and collector, collection only is used to match\n# as a second option, finally species only is used. \n# Records of the matching process are output in the \"matchingTable\" output of this step. \n\ndef addLocationsToTaxon(taxon): \n    global occurrences\n    global foundSpeciesAndCollectorNumber\n    global foundSpecies\n    global foundCollector\n    global inputTableIndex\n    #some taxon names are in single quotes because of a dot in the name, \n    # i.e. 'standleyi_L80,0894', so remove the single quotes\n    noquotes = taxon['node_data']['node name'].lower().replace(\"'\",\"\")\n    # separate species from collector number by looking for the '_' used between species and number\n    components = noquotes.lower().split(\" \")\n\n    if len(components)>1:\n        taxon_genus = components[0]\n        taxon_species = components[1]\n        # construct full name with genus + species\n        taxon_name = taxon_genus + ' ' + taxon_species\n    else:\n        taxon_genus = noquotes\n        taxon_name = taxon_genus\n        taxon_species = ''\n\n    #print \"found taxon:\",taxon_species,taxon_collector\n    # now look for matches\n    for occurrence in occurrences['rows']:\n        occurrrence_name = occurrence_species =  occurrence['SPECIES'].lower()\n        occurrence_genus = occurrence['SPECIES'].lower().split(' ')[0]\n        #occurrence_species = components[1]\n        # construct occurrence name to match tree names\n        #occurrrence_name = occurrence_genus + ' ' + occurrence_species\n        if (occurrrence_name == taxon_name):\n            foundSpeciesAndCollectorNumber = foundSpeciesAndCollectorNumber+1\n            #if this is the first occurrence found, create a new list, otherwise add to the existing list\n            if 'loc' in taxon['node_data'].keys():\n                taxon['node_data']['loc'].append([occurrence['LONG'],occurrence['LAT']])\n            else:\n                taxon['node_data']['loc'] = [[occurrence['LONG'],occurrence['LAT']]]\n            # add the collector column entry to the taxon record so we can cross reference with morphology later\n            attribRecord = {}\n            attribRecord['species'] = occurrence['SPECIES']\n            \n            # add columns from occurrence matrix to record\n            for attrib in occurrence:\n                attribRecord[attrib] = occurrence[attrib]\n            \n            # add under the attributes tag in the taxon\n            if 'attributes' in taxon['node_data'].keys():\n                taxon['node_data']['attributes'].append(attribRecord)\n            else:\n                taxon['node_data']['attributes'] = [attribRecord]\n            #makeMatchingEntry('species',occurrence_genus,occurrence_species,taxon_genus,taxon_name)\n\n\n# look through the morph matrix and return a row that matches the search key (e.g. particular value for field 'Numb')\n# if there is no matching key records in the morph table, return no matches.  \n\ndef returnMatchingMorphRecord(searchkey):\n    global morphtable\n    for row in morphtable['rows']:\n        # only continue if there is a matching header in the morph table\n        if matchColumn in row.keys():\n            if row[matchColumn] == searchkey:\n                return {'status': True, 'data': row}\n    return  {'status': False}\n            \n\n# this routine looks through the morphology matrix for key matches to the attribute added to the taxon.\n# all matching attributes are added to the 'attributes' list stored at the taxon level. The taxon 'attributes'\n# list has a list of records, each corresponding to a single occurrence that was matched to the taxon. In this \n# method, we simply find a matching record in the morphology table and copy the attribute columns into the taxon\n# node of the tree to \"flush out\" the tree with trait data for later analysis and visualization\n\ndef addMorphologyToTaxon(taxon):\n    global foundMorphology\n    if 'attributes' in taxon['node_data'].keys():\n        # loop through each occurrence record and expand the attribute record from just the number to include attributes\n        for attribRecord in taxon['node_data']['attributes']:\n            morphRecord = returnMatchingMorphRecord(attribRecord[matchColumn])\n            if morphRecord['status']:\n                foundMorphology += 1\n                # rebuild the components of the taxon name for the reporting\n                noquotes = taxon['node_data']['node name'].replace(\"'\",\"\")\n                components = noquotes.split(\"_\")\n                taxon_species = components[0]\n                taxon_collector = components[1]\n                makeMatchingEntry('morph',morphRecord['data'],taxon_species,taxon_collector,taxon)\n                #print morphRecord['data']\n                for attrib in morphRecord['data']:\n                    # store all records besides the key, because we have that already\n                    if attrib != matchColumn:\n                        attribRecord[attrib] = morphRecord['data'][attrib]\n  \n\n# -------- top level methods below --------------------\n\n# this routine traverses a phylo tree in nested format and add lat,long from\n# the occurrence records to the node.  This is the top level of the recursive traversal of the tree. Traversal\n# starts from the top and continues past the intermediate nodes,  for each taxon reached, addLocationsToTaxon is called\n# a single time to possibly add any matching occurrences to the taxon's attributes\n\ndef addLocationsToTreeNodes(treenode):\n    # look at the current tree node and see if there are children or not\n    if 'children' in treenode.keys():\n        #case for a hierarchy node, traverse to all the children\n        for node in treenode['children']:\n            addLocationsToTreeNodes(node)\n    else:\n        #case for a taxa. Look through the occurrence and add records to \n        # this node\n        addLocationsToTaxon(treenode)\n\ndef traverseTreeNodesForMatchTable(treenode):\n    # look at the current tree node and see if there are children or not\n    if 'children' in treenode.keys():\n        #case for a hierarchy node, traverse to all the children\n        for node in treenode['children']:\n            traverseTreeNodesForMatchTable(node)\n    else:\n        #case for a taxa. Look through the occurrence and add records to \n        # this node\n        outputMatchesForTaxon(treenode)        \n        \n# this routine traverses a phylo tree in nested format and adds attributes from\n# the morphology matrix to the taxa nodes.  This should be run AFTER the \n# locations traversal because it relies on the matchColumn value (the ascension or \n# collection index number) to be present in the taxon node.  This traversal\n# could be combined with the location/match traversal for improved speed, but \n# this separate traversal is simpler in design.\n\ndef addMorphologyToTreeNodes(treenode):\n    # look at the current tree node and see if there are children or not\n    if 'children' in treenode.keys():\n        #case for a hierarchy node, traverse to all the children\n        for node in treenode['children']:\n            addMorphologyToTreeNodes(node)\n    else:\n        #case for a taxa. Look through the occurrence and add records to \n        # this node\n        addMorphologyToTaxon(treenode)        \n\n\n\n# this routine traverses a phylo tree in nested format. Add a nodeid and then\n# increment the count every time we encounter a node during a depth first search\n\ndef addUniqueIDsToTreeNodes(treenode):\n    global nodecount\n    treenode['node_data']['nodeid'] = nodecount\n    nodecount += 1\n    # look at the current tree node and see if there are children or not\n    if 'children' in treenode.keys():\n        #case for a hierarchy node, traverse to all the children\n        for node in treenode['children']:\n            addUniqueIDsToTreeNodes(node)\n        \n    \n# here are the top level actions, add locations and output the tree\naddLocationsToTreeNodes(tree)\n#addMorphologyToTreeNodes(tree)\naddUniqueIDsToTreeNodes(tree)\n# output statistics of how many matches per species\ntraverseTreeNodesForMatchTable(tree)\ntreeWithLocations = tree\n\n#print \"species and collector matches:\",foundSpeciesAndCollectorNumber\n#print \"species matches:\",foundSpecies\n\n# output status records\nstatusTable['rows'].append({'description': 'total occurrence records','value': len(occurrences['rows'])})\nstatusTable['rows'].append({'description': 'species and genus matches','value':foundSpeciesAndCollectorNumber})\nstatusTable['rows'].append({'description': 'genus only matches','value':foundSpecies})\nstatusTable['rows'].append({'description': 'morphology records merged','value':foundMorphology})\n\n\n"
}