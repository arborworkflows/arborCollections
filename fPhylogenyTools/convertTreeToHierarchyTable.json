{
    "inputs": [
        {
            "format": "nested",
            "name": "intree",
            "type": "tree"
        },
        {
            "default": "full",
            "domain": [
                "full",
                "compressed"
            ],
            "format": "text",
            "name": "mode",
            "type": "string"
        }
    ],
    "mode": "python",
    "name": "Convert Tree to Hierarchy Table",
    "outputs": [
        {
            "format": "rows",
            "name": "hierarchyTable",
            "type": "table"
        }
    ],
    "script": "import copy\n\n# input: intree (nested format)\n# output: hierarchyTable \n\noutstring = ''\noutfields = []\noutrows = []\nmaxpathlength = 0\naccumulator = {}\naccumulator['paths'] = []\naccumulator['nodenames'] = []\ntermDictionary = {}\n\n\n# generate column names for columns according to the longest paths\n# discovered and fill the outfields data structure\n\ndef createOutputColumns():\n    global outfields\n    global maxpathlength\n    # loop through the accumulated rows and find the longest path. Save\n    # this value in the global variable maxpathlength\n    for thispath in accumulator['paths']:\n        maxpathlength = max(maxpathlength,len(thispath))\n    for level in range(maxpathlength):\n        columnname = 'level'+str(level+1)\n        outfields.append(columnname)\n    \n\n# delayed output of a table.  We need to see how many columns are needed, so \n# we just accumulate the row elements in a local data structure.\n\ndef accumulateTableRows(nodename,path):\n    global accumulator\n    accumulator['paths'].append(path)\n    accumulator['nodenames'].append(nodename)\n\n    # fill the term dictionary with each word and keep the lowest\n    # column index that it is discovered in.  We ignore the last entry in \n    # each path, because this is the species itself.\n    for i in range(len(path)-1):\n        if path[i] not in termDictionary.keys():\n            # this is the first time we've seen this, record it and its position\n            termDictionary[path[i]] = i\n        else:\n            # save this highest position seen for this term \n            termDictionary[path[i]] = min(i,  termDictionary[path[i]])\n        \n        \ndef createOutputRows():\n    for nodeindex in range(len(accumulator['nodenames'])):\n        outputRow(accumulator['nodenames'][nodeindex],accumulator['paths'][nodeindex])\n        \n    \ndef outputRow(nodename,path):\n    global outstring\n    global outrows\n    global outfields\n    outrow = {}\n    print \"output a row: nodename:\",nodename,\"path:\",path\n    outstring += 'out: '\n    \n    #first clear out the output row\n    for column in outfields:\n        outrow[column] = ''\n        \n    for columncount in range(len(path)):\n        # find the index into the table depending on the position in the term\n        # dictionary unless it is the species name (at the end of the path)\n        if columncount == (len(path)-1):\n            currentcolumn = maxpathlength - len(path) + columncount\n        else:\n            currentcolumn = termDictionary[path[columncount]]\n        columnname = 'level'+str(currentcolumn+1)\n        outrow[columnname] = path[columncount]\n       \n    # add this row to the output table\n    outrows.append(outrow)\n    outstring += '\\n'\n\n\n#------ compressed output -----------------------------\n\n# return a list that contains only the non-empty entries from the passed list\n# ex. input of ['hi','','there'] returns  ['hi','there']\ndef deleteEmptyListEntries(thislist):\n    returnlist = []\n    for entry in thislist:\n        if len(entry)>0:\n            # only add non-empty entries with length >0 to the output\n            returnlist.append(entry)\n    return returnlist\n    \n\ndef createCompressedOutputColumns():\n    global outfields\n    global maxpathlength\n    # loop through the accumulated rows and find the longest path. Save\n    # this value in the global variable maxpathlength. Note only non-empty list elements are counted\n    for thispath in accumulator['paths']:\n        maxpathlength = max(maxpathlength,len(deleteEmptyListEntries(thispath)))\n    for level in range(maxpathlength):\n        columnname = 'level'+str(level+1)\n        outfields.append(columnname)\n\n# compress to the shortest possible list right justified in the columns\ndef createCompressedOutputRows():\n    for nodeindex in range(len(accumulator['nodenames'])):\n        outputCompressedRow(accumulator['nodenames'][nodeindex],deleteEmptyListEntries(accumulator['paths'][nodeindex]))\n        \n# compress to the shortest possible light right justified in the columns    \ndef outputCompressedRow(nodename,path):\n    global outstring\n    global outrows\n    global maxpathlength\n    outrow = {}\n\n    #first clear out the output row\n    for column in outfields:\n        outrow[column] = ''\n\n    print \"output a row: nodename:\",nodename,\"path:\",path\n    outstring += 'out: '\n    nonEmptyPathEntriesCount = len(deleteEmptyListEntries(path))\n    for columncount in range(nonEmptyPathEntriesCount):\n        # find the index into the table depending on the length of this path needed\n        # to allign all species at the right edge\n        currentcolumn = maxpathlength - nonEmptyPathEntriesCount + columncount\n        columnname = 'level'+str(currentcolumn+1)\n        # traverse down the path and advance through the columns by \n        # working through the column names that came from the input table\n        outrow[columnname] = path[columncount]\n\n    # add this row to the output table\n    outrows.append(outrow)\n    outstring += '\\n'\n\n# ------- end compressed output -------------------------\n    \ndef findNodeName(node):\n    nodename = ''\n    if 'node_data' in node.keys():\n        if 'node name' in node['node_data'].keys():\n            nodename = node['node_data']['node name']\n    return nodename\n    \n    \ndef recursiveHelper(node,path):\n    global outstring\n    nodename = findNodeName(node)\n    path.append(nodename)\n    print 'nodename:',nodename,'path:',path\n    outstring += 'found: ' + nodename +' \\n'\n    \n    # this is going to traverse all subtrees\n    if 'children' in node.keys():\n        # now traverse each path separately   \n        for tempnode in node['children']:\n            newpath = copy.deepcopy(path)\n            recursiveHelper(tempnode,newpath)\n\n    else:\n        nodename = findNodeName(node)\n        #print \"bottom: path:\",path\n        #outputRow(nodename,path)\n        accumulateTableRows(nodename,path)\n                \n\n                \n\nprint \"start new run\"        \n\nrecursiveHelper(intree,[])\n\nif mode=='full':\n    createOutputColumns()\n    createOutputRows()\nelif mode=='compressed':\n    createCompressedOutputColumns()\n    createCompressedOutputRows()\nelse:\n    print 'unsupported mode'\n\nhierarchyTable = {}\nhierarchyTable['fields'] = outfields\nhierarchyTable['rows'] = outrows\n\n"
}